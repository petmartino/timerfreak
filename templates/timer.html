<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>{{ sequence_name if sequence_name else sequence_id }} - TimerFreak</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
    <!-- Add this entire block inside your <head> section -->
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <link rel="manifest" href="/static/site.webmanifest"> <!-- Or /static/manifest.json -->
    <link rel="mask-icon" href="/static/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <!-- Traditional favicon.ico (optional if you have many PNGs, but good for broad support) -->
    <link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
    <style id="theme-style">
        /* Theme-specific styles ONLY. Other body/layout styles are in style.css */
        /*
         * This <style> block is now dynamically updated by JavaScript
         * to switch between light and dark themes. It only contains
         * rules that are subject to theme changes.
         * Default (light) theme is assumed if no class is added to <body>
         */
        body {
            background-color: #fff;
            color: #000;
        }

        .bar-container {
            background-color: #ddd;
        }

        /* Light mode disabled button style (default) */
        .btn-solid-3d[data-disabled="true"],
        .btn-solid-3d.disabled-link {
            background: #eee;
            color: #bbb;
            border-color: #bbb;
            text-shadow: 0 1px 0 white;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 1), inset 0 1px 20px rgba(0, 0, 0, 0), 0 3px 0 #bbb, 0 0 0 1px white, 0 3px 0 1px white, 0 10px 20px rgba(0, 0, 0, 0);
        }

        .btn-solid-3d[data-disabled="true"]:active,
        .btn-solid-3d.disabled-link:active {
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 1), inset 0 1px 20px rgba(0, 0, 0, 0), 0 2px 0 #bbb, 0 0 0 1px white, 0 2px 0 1px white, 0 10px 20px rgba(0, 0, 0, 0);
        }

        #text-bottom hr {
            /* Light theme footer line */
            border-top-color: #eee;
        }
    </style>
</head>

<body>
    <!-- Global Timeline Bar fixed at the top -->
    <div id="globalBarContainer">
        <div class="global-bar" id="globalBar"></div>
    </div>

    {% if sequence_name %}
    <h1 id="sequenceName">{{ sequence_name }}</h1>
    {% endif %}

    <div id="controls">
        <a href="#" class="btn-solid-3d btn-darkgreen btn-fixed-width" onclick="toggleStart(event)" id="startBtn">START</a>
        <a href="#" class="btn-solid-3d btn-orange btn-fixed-width" onclick="togglePause(event)" id="pauseBtn"
            data-disabled="true">PAUSE</a>
        <a href="#" class="btn-solid-3d btn-gray emoji-btn" onclick="toggleAdvanced(event)" id="advancedBtn">‚öôÔ∏è</a>
        <a href="#" class="btn-solid-3d btn-gray emoji-btn" onclick="toggleTheme(event)" id="theme-toggle"
            style="float: right;">üí°</a>
    </div>

    <!-- Advanced Controls Section -->
    <div id="advancedControls">
        <div>
            <label><input type="checkbox" id="loopToggle" onchange="updateLoopSettings()"> Loop Sequence</label>
            <label>Loops:
                <div id="loopCountGroup">
                    <a href="#" class="digit-button" onclick="decrementLoopCount(event)">-</a>
                    <input type="number" id="loopCount" min="1" placeholder="‚àû" value="" size="2"
                        onchange="updateLoopSettings()">
                    <a href="#" class="digit-button" onclick="incrementLoopCount(event)">+</a>
                </div>
            </label>
        </div>
        <div id="quickControls">
            <a href="#" style="margin-top: 10px;"class="btn-solid-3d btn-default" onclick="restartCurrent(event)" id="restartCurrent"
                data-disabled="true">Restart Current</a>
            <a href="#" style="margin-top: 10px;" class="btn-solid-3d btn-default" onclick="restartAll(event)" id="restartAll"
                data-disabled="true">Restart Sequence</a>
            <div id="jumpButtons"></div>
        </div>
    </div>
    <div id="bars"></div>
    <div id="text-bottom">
        
                        <div ><a href="{{ url_for('show_timer', sequence_id=sequence_id) }}">{{ base_url }}{{ url_for('redirect_to_timer',
                sequence_id=sequence_id) }}</a></div>
                <p>&nbsp; &#8627; This is the permanent URL for this sequence. To easily access later <strong>Add to Home Screen (on Mobile)</strong> by tapping the share icon (iOS) or menu icon (Android) in your
                browser, then look for "Add to Home Screen" or "Install App". This will create an app-like icon on your
                device. <strong>On Desktop</strong>, press <kbd>Ctrl+D</kbd> (Windows/Linux) or <kbd>Cmd+D</kbd> (macOS)
                to bookmark this page. You can also drag the URL from the address bar to your bookmarks bar.
        
                </p>

        <audio id="alarm" src="" preload="auto"></audio>
        <!-- Background audio element for keeping audio engine alive -->
        <audio id="backgroundAlarm" src="{{ url_for('static', filename='silence.mp3') }}" loop preload="auto"
            volume="0"></audio>

        

       
    </div>
    {% include 'footer.html' %}
    <script>
        console.log("timer.html loaded");
        const durations = {{ timers | tojson }};
        const timerNames = {{ timer_names | tojson }};
        const sequenceId = "{{ sequence_id }}";
        const timerColors = {{ timer_colors | tojson }};
        const timerAlarmSounds = {{ timer_alarm_sounds | tojson }}; // Specific sounds for each timer

        const staticBaseUrl = "{{ url_for('static', filename='') }}";

        console.log("Durations:", durations);
        console.log("Timer Names:", timerNames);
        console.log("Sequence ID:", sequenceId);
        console.log("Timer Colors:", timerColors);
        console.log("Timer Alarm Sounds (specific):", timerAlarmSounds);
        const totalDuration = durations.reduce((a, b) => a + b, 0);
        console.log("Total Sequence Duration:", totalDuration);

        let current = 0; // Current timer index (0-based)
        let elapsed = 0; // Elapsed time for the current timer
        let globalElapsed = 0; // Total elapsed time across sequence
        let loopIndex = 0; // Current loop number
        let animationFrameId = null; // Stores requestAnimationFrame ID
        let intervalId = null; // Stores setTimeout/setInterval ID for background
        let paused = false;
        let running = false;
        let timestamps = [];
        let bars = []; // DOM elements for timers
        let loopEnabled = false;
        let loopLimit = null;
        let startTime = null; // Reference time for the current timer's elapsed calculation
        let pauseStartTime = null; // Time when pause was initiated
        // lastUpdateTime will now ONLY be used to calculate delta for globalElapsed in background, 
        // elapsed is always calculated from startTime.
        let lastUpdateTime = performance.now();

        // AudioContext for synthesized beeps
        let audioContext;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Play a quick synthesized beep
        function playBeep(frequency = 15000, duration = 0.15, volume = 1) { // A7 note for higher pitch
            initAudioContext();
            if (!audioContext) {
                console.warn("AudioContext not available, cannot play beep.");
                return;
            }
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'play'; // Sine wave for a clean beep
            oscillator.frequency.value = frequency;

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            // gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration); // Fade out

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Helper to set/get disabled state for links
        function setLinkDisabled(linkElement, disabled) {
            if (!linkElement) {
                console.warn("Attempted to set disabled state on a null element. This might be a timing issue or element not found.");
                return;
            }
            if (disabled) {
                linkElement.setAttribute('data-disabled', 'true');
                linkElement.classList.add('disabled-link');
            } else {
                linkElement.removeAttribute('data-disabled');
                linkElement.classList.remove('disabled-link');
            }
        }

        function isLinkDisabled(linkElement) {
            if (!linkElement) return true;
            return linkElement.getAttribute('data-disabled') === 'true';
        }

        // Helper to set button text/emoji and class for consistent size
        // Uses CSS min-width for fixed button size.
        function setButtonState(buttonId, text, colorClass) {
            const button = document.getElementById(buttonId);
            if (!button) return;

            // Remove all existing color classes except btn-solid-3d (and emoji-btn/btn-fixed-width if applicable)
            button.className = 'btn-solid-3d'; // Reset base classes
            if (buttonId === 'advancedBtn' || buttonId === 'theme-toggle') {
                button.classList.add('emoji-btn');
            } else if (buttonId === 'startBtn' || buttonId === 'pauseBtn') {
                button.classList.add('btn-fixed-width');
            }
            // Add the new color class
            button.classList.add(colorClass);

            button.innerHTML = text; // Set text directly, CSS min-width handles sizing
        }


        // --- Event handlers for link buttons ---
        function toggleStart(event) {
            event.preventDefault();
            if (isLinkDisabled(event.target)) return;
            playBeep(4400, 0.1,.1); // High pitch for start
            _toggleStart();
        }

        function togglePause(event) {
            event.preventDefault();
            if (isLinkDisabled(event.target)) return;
            playBeep(4400, 0.1,.1); // Low pitch for other interactions
            _togglePause();
        }

        function restartCurrent(event) {
            event.preventDefault();
            if (isLinkDisabled(event.target)) return;
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            _restartCurrent();
        }

        function restartAll(event) {
            event.preventDefault();
            if (isLinkDisabled(event.target)) return;
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            _restartAll();
        }

        function toggleAdvanced(event) {
            event.preventDefault();
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            const advancedControls = document.getElementById("advancedControls");

            // Toggle the 'show' class
            advancedControls.classList.toggle("show");

            // Toggle disabled state for buttons inside advanced controls
            const advancedButtons = advancedControls.querySelectorAll('.btn-solid-3d');
            advancedButtons.forEach(btn => {
                // If the panel is now showing, enable the buttons; if hiding, disable them.
                setLinkDisabled(btn, !advancedControls.classList.contains("show"));
            });
        }

        function toggleTheme(event) {
            event.preventDefault();
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            _toggleTheme();
        }

        function jumpToTimer(index, event) {
            event.preventDefault();
            if (isLinkDisabled(event.target)) return;
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            _jumpToTimer(index);
        }

        function incrementLoopCount(event) {
            event.preventDefault();
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            const input = document.getElementById("loopCount");
            let value = parseInt(input.value);
            if (isNaN(value) || value < 0) { value = 0; }
            input.value = value + 1;
            updateLoopSettings();
        }

        function decrementLoopCount(event) {
            event.preventDefault();
            playBeep(880, 0.05,.01); // Low pitch for other interactions
            const input = document.getElementById("loopCount");
            let value = parseInt(input.value);
            if (isNaN(value) || value <= 1) {
                input.value = "";
            } else {
                input.value = value - 1;
            }
            updateLoopSettings();
        }
        // --- End of Event handlers for link buttons ---

        // === Helper for playing alarm sound ===
        function playAlarmSound(soundFileName) {
            const alarm = document.getElementById("alarm");
            const backgroundAlarm = document.getElementById("backgroundAlarm");

            if (!alarm) {
                console.error("Audio element #alarm not found.");
                return;
            }
            if (!backgroundAlarm) {
                console.warn("Background audio element #backgroundAlarm not found. Background audio might not be robust.");
            }

            // Always stop previous playback before starting new one
            alarm.pause();
            alarm.currentTime = 0;

            if (!soundFileName) {
                console.warn(`No valid alarm sound file specified for playback, or it's empty.`);
                alarm.src = "";
                return;
            }

            alarm.src = staticBaseUrl + soundFileName;
            alarm.load(); // Explicitly load the media for robustness

            const playPromise = alarm.play();

            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log(`Alarm sound ${soundFileName} started playing.`);
                    // When main alarm plays, temporarily pause background audio if it exists and is playing, to ensure main alarm is heard
                    if (backgroundAlarm && !backgroundAlarm.paused && backgroundAlarm.volume === 0) {
                        backgroundAlarm.pause(); // Pause the silent background track
                        // After main alarm ends, restart background audio
                        alarm.addEventListener('ended', function restartBgAlarm() {
                            if (backgroundAlarm) {
                                backgroundAlarm.currentTime = 0; // Reset it to avoid skipping if it was paused partway
                                backgroundAlarm.play().catch(e => console.warn("Failed to restart background audio after alarm:", e));
                            }
                            alarm.removeEventListener('ended', restartBgAlarm); // Remove listener after it fires once
                        }, { once: true }); // Ensure this listener fires only once
                    }
                }).catch(e => {
                    console.error(`Error playing alarm sound ${soundFileName}:`, e);
                    if (e.name === 'NotAllowedError') {
                        console.warn("Autoplay blocked, user interaction required to enable sound.");
                    }
                    // If playing main alarm fails, ensure background alarm is attempted to be restarted
                    if (backgroundAlarm && backgroundAlarm.paused && backgroundAlarm.volume === 0) {
                        backgroundAlarm.play().catch(e => console.warn("Failed to restart background audio on main alarm play error:", e));
                    }
                });
            } else {
                console.error("play() did not return a promise.");
                // If playing main alarm fails, ensure background alarm is attempted to be restarted
                if (backgroundAlarm && backgroundAlarm.paused && backgroundAlarm.volume === 0) {
                    backgroundAlarm.play().catch(e => console.warn("Failed to restart background audio on main alarm play error:", e));
                }
            }
        }


        function updateCompletionBar() {
            let totalElapsedPercentage = Math.min((globalElapsed / totalDuration) * 100, 100);
            document.getElementById("globalBar").style.width = totalElapsedPercentage + "%";
        }

        function initUI() {
            const barsContainer = document.getElementById('bars');
            const jump = document.getElementById('jumpButtons');
            barsContainer.innerHTML = '';
            jump.innerHTML = '';
            bars = [];

            for (let i = 0; i < durations.length; i++) {
                const outer = document.createElement('div');
                outer.className = "bar-container";

                const inner = document.createElement('div');
                inner.className = "bar";
                inner.style.backgroundColor = timerColors[i];
                outer.appendChild(inner);

                const timerInfoDiv = document.createElement('div');
                timerInfoDiv.className = "timer-info";
                const timerInfoNameDiv = document.createElement('div');
                timerInfoNameDiv.className = "timer-info-name";
                timerInfoNameDiv.textContent = timerNames[i] || `Timer ${i + 1}`;
                timerInfoDiv.appendChild(timerInfoNameDiv);
                const timerInfoDurationDiv = document.createElement('div');
                timerInfoDurationDiv.className = "timer-info-duration";
                timerInfoDurationDiv.textContent = `${durations[i]} seconds`;
                timerInfoDiv.appendChild(timerInfoDurationDiv);
                outer.appendChild(timerInfoDiv);

                const overlayDiv = document.createElement('div');
                overlayDiv.className = "overlay";
                const overlayContentDiv = document.createElement('div');
                overlayContentDiv.className = "overlay-content";

                const timerNameDiv = document.createElement('div');
                timerNameDiv.className = "timer-name";
                timerNameDiv.textContent = timerNames[i] || `Timer ${i + 1}`;
                overlayContentDiv.appendChild(timerNameDiv);

                const timerCountdownDiv = document.createElement('div');
                timerCountdownDiv.className = "timer-countdown";
                timerCountdownDiv.textContent = `${durations[i]} seconds`;
                overlayContentDiv.appendChild(timerCountdownDiv);

                overlayDiv.appendChild(overlayContentDiv);
                outer.appendChild(overlayDiv);

                // Initial state for all timers on load: overlay visible, info hidden
                overlayDiv.style.display = "flex";
                timerInfoDiv.style.display = "none";

                barsContainer.appendChild(outer);
                bars.push(outer);
            }

            jump.innerHTML = '';
            for (let i = 0; i < durations.length; i++) {
                const jumpBtn = document.createElement("a");
                jumpBtn.href = "#";
                jumpBtn.className = "btn-solid-3d btn-small btn-default jump-button"; // Added jump-button class
                const btnText = timerNames[i] ? `Go to ${timerNames[i]}` : `Go to ${i + 1}`;
                jumpBtn.textContent = btnText;
                jumpBtn.onclick = (e) => jumpToTimer(i, e);
                setLinkDisabled(jumpBtn, true); // Initially disabled
                jump.appendChild(jumpBtn);
            }
        }

        function resetTimestamps() {
            timestamps = new Array(durations.length).fill(null).map(() => ({
                start: null,
                end: null
            }));
        }

        function logActivity(eventType, timerOrder = null) {
            fetch('/log_activity', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sequence_id: sequenceId,
                    timer_order: timerOrder,
                    event_type: eventType
                })
            })
                .then(response => {
                    if (!response.ok) {
                        console.error('Failed to log activity:', response.status);
                    }
                })
                .catch(error => {
                    console.error('Error logging activity:', error);
                });
        }

        function _toggleStart() {
            if (running) {
                stopSequence();
                return;
            }

            initUI(); // Re-initializes bars, setting all to overlay state (flex)
            resetTimestamps();
            updateLoopSettings();

            // Start background audio to keep audio engine alive
            const backgroundAlarm = document.getElementById("backgroundAlarm");
            if (backgroundAlarm) {
                backgroundAlarm.volume = 0; // Ensure it's silent
                backgroundAlarm.play().catch(e => console.warn("Failed to start background audio:", e));
            }

            // Set button states
            setButtonState('startBtn', "STOP", 'btn-red'); // Updated name and color, NO ¬†
            setLinkDisabled(document.getElementById("pauseBtn"), false);
            setLinkDisabled(document.getElementById("restartCurrent"), false);
            setLinkDisabled(document.getElementById("restartAll"), false);
            // Ensure jump buttons are enabled when sequence starts
            document.querySelectorAll(".jump-button").forEach(link => setLinkDisabled(link, false));


            running = true;
            paused = false;
            elapsed = 0;
            globalElapsed = 0;
            loopIndex = 1;

            updateCompletionBar();
            // updateDebug(); // Debug info removed from GUI

            pauseStartTime = null;
            startTime = performance.now() / 1000; // Initialize startTime directly
            lastUpdateTime = performance.now(); // Initialize for accurate time tracking
            logActivity('sequence_start');
            startTimer(0);
        }

        let stopSequenceFinalAlarmEndedHandler = null; // To store listener for final alarm
        let stopSequenceFinalAlarmTimeoutId = null; // New ID for final alarm delay (fallback)
        let stopSequenceCleanupTimeoutId = null; // ID for actual cleanup

        function stopSequence() {
            running = false;
            paused = false;
            current = 0;
            elapsed = 0;
            globalElapsed = 0;

            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            clearInterval(intervalId);
            intervalId = null;

            // Clear any pending timeouts related to stopping
            if (stopSequenceFinalAlarmTimeoutId) {
                clearTimeout(stopSequenceFinalAlarmTimeoutId);
                stopSequenceFinalAlarmTimeoutId = null;
            }
            if (stopSequenceCleanupTimeoutId) {
                clearTimeout(stopSequenceCleanupTimeoutId);
                stopSequenceCleanupTimeoutId = null;
            }
            const alarmElement = document.getElementById("alarm");
            if (stopSequenceFinalAlarmEndedHandler) {
                alarmElement.removeEventListener('ended', stopSequenceFinalAlarmEndedHandler);
                stopSequenceFinalAlarmEndedHandler = null;
            }


            // Stop background audio
            const backgroundAlarm = document.getElementById("backgroundAlarm");
            if (backgroundAlarm) {
                backgroundAlarm.pause();
                backgroundAlarm.currentTime = 0;
            }

            if (bars) {
                bars.forEach(bar => {
                    bar.querySelector(".bar").style.width = "0%";
                    bar.querySelector(".overlay").style.display = "flex"; // Reset to overlay (as per initial state)
                    bar.querySelector(".timer-info").style.display = "none";
                });
            }
            document.getElementById("globalBar").style.width = "0%";
            // Set button states
            setButtonState('startBtn', "START", 'btn-darkgreen'); // Updated name and color, NO ¬†
            setButtonState('pauseBtn', "PAUSE", 'btn-orange'); // Reset Pause text and color, NO ¬†
            setLinkDisabled(document.getElementById("pauseBtn"), true);
            setLinkDisabled(document.getElementById("restartCurrent"), true);
            setLinkDisabled(document.getElementById("restartAll"), true);
            // Ensure jump buttons are disabled when sequence stops
            document.querySelectorAll(".jump-button").forEach(link => setLinkDisabled(link, true));

            // Final cleanup of the main alarm element
            if (alarmElement) {
                alarmElement.pause();
                alarmElement.currentTime = 0;
                alarmElement.src = ""; // Clear sound source
            }

            // updateDebug(); // Debug info removed from GUI
            logActivity('sequence_end');
        }

        function _togglePause() {
            paused = !paused;
            // Set button states
            setButtonState('pauseBtn', paused ? "RESUME" : "PAUSE", paused ? 'btn-darkgreen' : 'btn-orange'); // Updated color and name, NO ¬†
            // updateDebug(); // Debug info removed from GUI

            logActivity(paused ? 'pause_timer' : 'resume_timer', current);

            if (paused) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                clearInterval(intervalId);
                intervalId = null;
                pauseStartTime = performance.now(); // Store exact time of pause
            } else {
                // When resuming, adjust startTime by the duration of the pause
                const pauseDuration = performance.now() - pauseStartTime;
                startTime += pauseDuration / 1000; // startTime is in seconds
                lastUpdateTime = performance.now(); // Reset lastUpdateTime
                pauseStartTime = null;

                if (running) {
                    if (document.visibilityState === 'visible') {
                        animationFrameId = requestAnimationFrame(update);
                    } else {
                        // In background, use setInterval for updates
                        intervalId = setInterval(update, 100); // Call update periodically
                    }
                }
            }
        }

        function _restartCurrent() {
            const alarm = document.getElementById("alarm");
            if (alarm) {
                alarm.pause();
                alarm.currentTime = 0;
                alarm.src = "";
            }

            logActivity('restart_timer', current);

            globalElapsed = durations.slice(0, current).reduce((a, b) => a + b, 0);

            elapsed = 0;
            timestamps[current].start = new Date().toISOString();
            timestamps[current].end = null;
            startTime = performance.now() / 1000;
            lastUpdateTime = performance.now(); // Reset lastUpdateTime

            if (bars[current]) {
                bars[current].querySelector(".bar").style.width = "0%";
                bars[current].querySelector(".overlay").style.display = "flex";
                bars[current].querySelector(".timer-info").style.display = "none";
                bars[current].querySelector(".timer-countdown").textContent = `${durations[current]} (${0}%)`;
            }
            for (let i = 0; i < bars.length; i++) {
                if (i !== current) {
                    bars[i].querySelector(".bar").style.width = "0%";
                    bars[i].querySelector(".overlay").style.display = "none";
                    bars[i].querySelector(".timer-info").style.display = "flex";
                }
            }

            updateCompletionBar();

            if (!paused && running) {
                cancelAnimationFrame(animationFrameId);
                clearInterval(intervalId);
                animationFrameId = null;
                intervalId = null;

                if (document.visibilityState === 'visible') {
                    animationFrameId = requestAnimationFrame(update);
                } else {
                    intervalId = setInterval(update, 100);
                }
            } else if (!paused && !running) {
                _toggleStart();
            }
            // updateDebug(); // Debug info removed from GUI
        }

        function _restartAll() {
            logActivity('restart_sequence');
            stopSequence();
            _toggleStart();
            // updateDebug(); // Debug info removed from GUI
        }

        function _jumpToTimer(index) {
            if (index < 0 || index >= durations.length) {
                console.warn("Attempted to jump to invalid timer index:", index);
                return;
            }

            cancelAnimationFrame(animationFrameId);
            clearInterval(intervalId);
            animationFrameId = null;
            intervalId = null;

            const alarm = document.getElementById("alarm");
            if (alarm) {
                alarm.pause();
                alarm.currentTime = 0;
                alarm.src = "";
            }

            logActivity('goto_timer', index);

            // Correctly log end for the previous timer if it was running
            if (running && (typeof current === 'number' && current !== index) && timestamps[current] && timestamps[current].start && !timestamps[current].end) {
                timestamps[current].end = new Date().toISOString();
                logActivity('timer_end', current);
            }

            // Reset all timestamps up to the jumped-to index
            resetTimestamps();
            for (let i = 0; i < index; i++) {
                // Approximate start/end times for prior timers, assuming they ran for their full duration
                // For a jump, we mark prior ones as "completed instantly" for state tracking.
                timestamps[i].start = new Date().toISOString();
                timestamps[i].end = new Date().toISOString();
            }
            timestamps[index].start = new Date().toISOString(); // Mark the new current timer as started

            globalElapsed = durations.slice(0, index).reduce((a, b) => a + b, 0);
            updateCompletionBar();

            if (bars) {
                bars.forEach((bar, i) => {
                    // Reset all bars to default "info" state, then activate the current one
                    bar.querySelector(".bar").style.width = "0%";
                    // Initial state for all timers on load: overlay visible, info hidden
                    bar.querySelector(".overlay").style.display = "flex";
                    bar.querySelector(".timer-info").style.display = "none";
                    bar.querySelector(".timer-info-name").textContent = timerNames[i] || `Timer ${i + 1}`;
                    bar.querySelector(".timer-info-duration").textContent = `${durations[i]} seconds`;
                });
            }

            if (!running && !paused) {
                running = true;
                setButtonState('startBtn', "STOP", 'btn-red'); // Update Start/Stop button, NO ¬†
                setLinkDisabled(document.getElementById("pauseBtn"), false);
                setLinkDisabled(document.getElementById("restartCurrent"), false);
                setLinkDisabled(document.getElementById("restartAll"), false);
                document.querySelectorAll(".jump-button").forEach(link => setLinkDisabled(link, false));
            }

            if (!paused) {
                startTimer(index);
            } else {
                current = index;
                elapsed = 0;
                // If paused, just update UI for the new current timer
                if (bars[current]) {
                    bars[current].querySelector(".overlay").style.display = "flex";
                    bars[current].querySelector(".timer-info").style.display = "none";
                    bars[current].querySelector(".timer-countdown").textContent = `${durations[current]} (${0}%)`;
                }
            }
            // updateDebug(); // Debug info removed from GUI
        }

        function startTimer(timerIndex) {
            // Clear any pending stop sequence timeout from a previous final alarm
            if (stopSequenceCleanupTimeoutId) {
                clearTimeout(stopSequenceCleanupTimeoutId);
                stopSequenceCleanupTimeoutId = null;
            }

            // Clear any previous final alarm fallback timeout
            if (stopSequenceFinalAlarmTimeoutId) {
                clearTimeout(stopSequenceFinalAlarmTimeoutId);
                stopSequenceFinalAlarmTimeoutId = null;
            }
            // Remove previous final alarm ended handler
            const alarmElement = document.getElementById("alarm");
            if (stopSequenceFinalAlarmEndedHandler) {
                alarmElement.removeEventListener('ended', stopSequenceFinalAlarmEndedHandler);
                stopSequenceFinalAlarmEndedHandler = null;
            }


            cancelAnimationFrame(animationFrameId);
            clearInterval(intervalId);
            animationFrameId = null;
            intervalId = null;

            current = timerIndex;
            elapsed = 0;
            startTime = performance.now() / 1000;
            lastUpdateTime = performance.now(); // Reset lastUpdateTime for accurate start

            timestamps[current].start = new Date().toISOString();
            logActivity('timer_start', current);

            // Set only the current timer's overlay to flex, others to info
            bars.forEach((bar, i) => {
                const overlay = bar.querySelector(".overlay");
                const timerInfo = bar.querySelector(".timer-info");
                if (i === current) {
                    overlay.style.display = "flex";
                    timerInfo.style.display = "none";
                } else {
                    overlay.style.display = "none";
                    timerInfo.style.display = "flex";
                }
            });


            if (document.visibilityState === 'visible') {
                animationFrameId = requestAnimationFrame(update);
            } else {
                intervalId = setInterval(update, 100);
            }
        }

        function update(currentTime) {
            if (!running || paused) {
                cancelAnimationFrame(animationFrameId);
                clearInterval(intervalId);
                animationFrameId = null;
                intervalId = null;
                return;
            }

            // Always calculate elapsed from startTime for accuracy.
            elapsed = (performance.now() / 1000) - startTime;
            // globalElapsed also relies on this current elapsed
            globalElapsed = durations.slice(0, current).reduce((a, b) => a + b, 0) + elapsed;
            lastUpdateTime = performance.now(); // Update for next iteration

            // Check for end of timer *before* potentially stopping sequence
            if (elapsed >= durations[current]) {
                timestamps[current].end = new Date().toISOString();
                logActivity('timer_end', current);

                playAlarmSound(timerAlarmSounds[current]); // Play alarm as soon as timer ends

                const nextTimerIndex = current + 1;
                const isLastTimerInSequence = nextTimerIndex >= durations.length;
                const willLoop = loopEnabled && (!loopLimit || loopIndex < loopLimit);

                if (isLastTimerInSequence && !willLoop) {
                    // This is the very last timer and no looping
                    const alarmElement = document.getElementById("alarm");

                    // Clear any previous final alarm specific listeners
                    if (stopSequenceFinalAlarmEndedHandler) {
                        alarmElement.removeEventListener('ended', stopSequenceFinalAlarmEndedHandler);
                        stopSequenceFinalAlarmEndedHandler = null;
                    }

                    // Define the handler for when the FINAL alarm sound ends
                    stopSequenceFinalAlarmEndedHandler = () => {
                        console.log("Final alarm ended. Initiating sequence stop cleanup.");
                        // Clear the fallback timeout if alarm actually ended
                        if (stopSequenceFinalAlarmTimeoutId) {
                            clearTimeout(stopSequenceFinalAlarmTimeoutId);
                            stopSequenceFinalAlarmTimeoutId = null;
                        }
                        stopSequenceCleanupTimeoutId = setTimeout(() => { // Small delay before cleanup
                            stopSequence();
                            stopSequenceCleanupTimeoutId = null;
                        }, 100); // Give browser a moment after onended fires
                        alarmElement.removeEventListener('ended', stopSequenceFinalAlarmEndedHandler); // Remove self
                        stopSequenceFinalAlarmEndedHandler = null; // Clear ref
                    };

                    // Give audio element a moment to process .src and .load() before adding listener
                    setTimeout(() => {
                        // Attach the listener only if there's a sound and it's not already ended/errored
                        if (alarmElement && alarmElement.src && !alarmElement.ended && alarmElement.networkState === HTMLMediaElement.NETWORK_IDLE) { // Ensure it's not already ended or errored
                            // Attach a one-time listener for the 'ended' event
                            alarmElement.addEventListener('ended', stopSequenceFinalAlarmEndedHandler);

                            // Set a fallback timeout in case 'ended' event doesn't fire (e.g., autoplay issues)
                            stopSequenceFinalAlarmTimeoutId = setTimeout(() => {
                                if (running) { // Only stop if still running (i.e., sound didn't finish or didn't start)
                                    console.warn("Final alarm did not end as expected or autoplay failed. Stopping sequence after timeout.");
                                    stopSequence();
                                }
                            }, Math.max(8000, (alarmElement.duration * 1000) + 1000)); // 8s minimum, or sound duration + 1s buffer
                        } else {
                            // No sound, or sound immediately finished playing, or there was an error.
                            // Proceed to stop sequence directly after a very small delay.
                            console.log("No final alarm sound or it completed instantly/errored. Stopping sequence immediately.");
                            stopSequenceCleanupTimeoutId = setTimeout(() => {
                                stopSequence();
                                stopSequenceCleanupTimeoutId = null;
                            }, 100);
                        }
                    }, 50); // Small delay to allow src and load to process

                    // Importantly: Halt the regular update loop for this *specific final* step
                    // so no more elapsed time accrues and we explicitly wait for sound.
                    return;
                } else if (nextTimerIndex < durations.length) {
                    startTimer(nextTimerIndex); // Advance to next timer immediately
                } else if (willLoop) {
                    loopIndex++;
                    resetTimestamps();
                    startTimer(0); // Restart sequence for loop
                }
            }

            // Continue UI updates for the *current* timer until it ends
            // This part only executes if the current timer has *not* just ended
            // or if it just ended but wasn't the final one.
            if (current < durations.length) {
                const barOuter = bars[current]; // Directly reference the current bar for updates
                const barInner = barOuter.querySelector(".bar");
                const overlay = barOuter.querySelector(".overlay");
                const overlayContent = overlay.querySelector(".overlay-content");

                const timerNameDiv = overlayContent.querySelector(".timer-name");
                const timerCountdownDiv = overlayContent.querySelector(".timer-countdown");

                // Update properties for the current timer's visual elements
                barInner.style.width = Math.min((elapsed / durations[current]) * 100, 100) + "%";
                overlay.style.display = "flex";
                barOuter.querySelector(".timer-info").style.display = "none"; // Hide info for current

                timerNameDiv.textContent = timerNames[current] || `Timer ${current + 1}`;
                const remainingTime = Math.max(0, durations[current] - elapsed);

                let countdownText = "";
                const hours = Math.floor(remainingTime / 3600);
                const minutes = Math.floor((remainingTime % 3600) / 60);
                const seconds = Math.floor(remainingTime % 60);

                if (hours > 0) {
                    countdownText += `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                } else if (minutes > 0) {
                    countdownText += `${minutes}:${String(seconds).padStart(2, '0')}`;
                } else {
                    countdownText += seconds;
                }

                countdownText += ` (${Math.min((elapsed / durations[current]) * 100, 100).toFixed(0)}%)`;

                timerCountdownDiv.textContent = countdownText;

                // Ensure other bars are set to info state if they were previously active
                for (let i = 0; i < bars.length; i++) {
                    if (i !== current) {
                        const otherBarOuter = bars[i];
                        const otherBarInner = otherBarOuter.querySelector(".bar");
                        const otherOverlay = otherBarOuter.querySelector(".overlay");
                        const otherTimerInfo = otherBarOuter.querySelector(".timer-info");

                        // Only change if needed to avoid unnecessary DOM writes
                        if (otherBarInner.style.width !== "0%" || otherOverlay.style.display !== "none") {
                            otherBarInner.style.width = "0%";
                            otherOverlay.style.display = "none";
                            otherTimerInfo.style.display = "flex";
                        }
                    }
                }
            }


            updateCompletionBar();
            updateDebug(); // Keep for console logging


            if (document.visibilityState === 'visible') {
                animationFrameId = requestAnimationFrame(update);
            }
            // If in background, setInterval handles updates, no need for rAF here
        }


        // updateDebug function for console logging (removed from GUI)
        function updateDebug() {
            let debugText = durations.map((dur, i) => {
                let state = "Stopped",
                    pct = 0,
                    secs = 0;

                if (i === current && running && !paused) {
                    state = "Running";
                    pct = (elapsed / dur * 100).toFixed(2);
                    secs = elapsed.toFixed(2);
                } else if (i === current && running && paused) {
                    state = "Paused";
                    pct = (elapsed / dur * 100).toFixed(2);
                    secs = elapsed.toFixed(2);
                } else if (timestamps[i] && timestamps[i].end) {
                    state = "Finished";
                    pct = "100.00";
                    secs = dur.toFixed(2);
                } else if (i < current && running && !paused) {
                    state = "Finished (Passed)";
                    pct = "100.00";
                    secs = dur.toFixed(2);
                } else {
                    state = "Waiting";
                    pct = "0.00";
                    secs = "0.00";
                }
                return `Timer ${i + 1}/${durations.length}: Status: ${state} | Progress: ${pct}% | ${secs}/${dur.toFixed(2)}s\nStart: ${timestamps[i] ? timestamps[i].start || "-" : "-"}\nEnd: ${timestamps[i] ? timestamps[i].end || "-" : "-"}`;
            });
            const loopStatus = loopEnabled ? `Looping: ON (${loopLimit !== null ? loopLimit : '‚àû'}x)` : `Looping: OFF`;
            const sequenceStatus = running ? (paused ? "Paused" : "Running") : "Stopped";
            const globalElapsedFormatted = globalElapsed.toFixed(2);
            const globalProgress = totalDuration > 0 ? (globalElapsed / totalDuration * 100).toFixed(2) : "0.00";

            console.log(
                `Sequence Status: ${sequenceStatus} | ${loopStatus}\n` +
                `Current Loop: ${loopIndex} of ${loopLimit !== null ? loopLimit : '‚àû'}\n` +
                `Global Progress: ${globalElapsedFormatted}s / ${totalDuration.toFixed(2)}s (${globalProgress}%)\n\n` +
                debugText.join("\n\n")
            );
        }

        function updateLoopSettings() {
            loopEnabled = document.getElementById("loopToggle").checked;
            const loopVal = parseInt(document.getElementById("loopCount").value);
            loopLimit = isNaN(loopVal) || loopVal < 1 ? null : loopVal;
            updateDebug();
        }

        function _toggleTheme() {
            const bodyElement = document.body;
            if (!bodyElement) {
                console.error("Body element not found!");
                return;
            }

            const isLight = !bodyElement.classList.contains('dark-theme');

            if (isLight) {
                bodyElement.classList.add('dark-theme');
                setButtonState('theme-toggle', "‚òÄÔ∏è", 'btn-gray'); // Moon emoji for dark mode
            } else {
                bodyElement.classList.remove('dark-theme');
                setButtonState('theme-toggle', "üåô", 'btn-gray'); // Light bulb emoji for light mode
            }
        }

        // --- Background/Foreground Visibility Handling ---
        document.addEventListener('visibilitychange', () => {
            if (running && !paused) {
                if (document.visibilityState === 'visible') {
                    console.log("Tab is visible. Switching to requestAnimationFrame.");
                    clearInterval(intervalId); // Stop setInterval
                    intervalId = null;

                    // Re-sync time
                    const now = performance.now();
                    startTime = now / 1000 - elapsed; // Adjust startTime based on current elapsed
                    lastUpdateTime = now; // Reset lastUpdateTime for rAF

                    animationFrameId = requestAnimationFrame(update); // Start rAF
                } else {
                    console.log("Tab is hidden. Switching to setInterval for background updates.");
                    cancelAnimationFrame(animationFrameId); // Stop rAF
                    animationFrameId = null;

                    // Re-sync time
                    lastUpdateTime = performance.now(); // Reset lastUpdateTime for setInterval

                    if (!intervalId) { // Only set if not already set
                        intervalId = setInterval(update, 100); // Start setInterval
                    }
                }
            } else {
                // If not running or paused, ensure both are stopped
                cancelAnimationFrame(animationFrameId);
                clearInterval(intervalId);
                animationFrameId = null;
                intervalId = null;
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            initUI(); // Initialize bars, sets all to overlay (active) state
            updateDebug(); // Initial console logging
            // Initial setup for advanced controls links to be disabled.
            // Advanced controls are initially hidden, so their buttons should be disabled.
            document.querySelectorAll("#advancedControls .btn-solid-3d").forEach(link => setLinkDisabled(link, true));

            // Set initial states for main buttons with specific colors and fixed width
            // Note: `btn-fixed-width` class added to style.css to ensure these have minimum width
            setButtonState('startBtn', "START", 'btn-darkgreen');
            setButtonState('pauseBtn', "PAUSE", 'btn-orange');
            setButtonState('advancedBtn', "‚öôÔ∏è", 'btn-gray');
            setButtonState('theme-toggle', "üåô", 'btn-gray');
            setLinkDisabled(document.getElementById("advancedBtn"), false); // Advanced button always enabled

            // Initial play of background silent audio (user interaction might be needed on first load)
            const backgroundAlarm = document.getElementById("backgroundAlarm");
            if (backgroundAlarm) {
                backgroundAlarm.volume = 0; // Ensure it's silent
                backgroundAlarm.play().catch(e => {
                    console.warn("Autoplay of silent background audio blocked. User interaction required for robust background audio:", e);
                    // Provide instruction to user if possible, e.g., a "Play sound" button on first interaction.
                    // For this app, simply let them know it might not work in background until first interaction.
                });
            }
        });
    </script>
</body>

</html>